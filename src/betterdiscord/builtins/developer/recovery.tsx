import Button, {Colors} from "@ui/base/button";
import React from "@modules/react";
import Logger from "@common/logger";
import DiscordModules from "@modules/discordmodules";
import {t} from "@common/i18n";
import Builtin from "@structs/builtin";
import Settings from "@stores/settings";
import Toasts from "@stores/toasts";
import pluginmanager from "@modules/pluginmanager";
import IPC from "@modules/ipc";
import Modals from "@ui/modals";
import {getByKeys, getByPrototypes, getByStrings, getMangled} from "@webpack";
import NotificationUIInstance from "@ui/notifications";
import config from "@stores/config";
import {Logo} from "@ui/logo";
import clsx from "clsx";

const Dispatcher = DiscordModules.Dispatcher;
const TEST_PLUGIN_REGEX = /betterdiscord:\/\/(plugins)\/(.*?).(\w+).js/;

// TODO: arven if you get a chance
async function attemptRecovery() {
    const transitionTo = getByStrings(["transitionTo - Transitioning to"], {searchExports: true});
    const modalModule = getMangled(`,["contextKey"]),`, {CloseAllModals: x => x.toString?.()?.includes(".key,") && x.toString?.()?.includes("getState();")});

    const recoverySteps = [
        {
            action: () => Dispatcher?.dispatch?.({type: "LAYER_POP_ALL"}),
            errorMessage: "Failed to pop all layers"
        },
        {
            action: () => Dispatcher?.dispatch?.({type: "MODAL_POP_ALL"}),
            errorMessage: "Failed to pop all modals"
        },
        {
            action: () => transitionTo?.("/channels/@me"),
            errorMessage: "Failed to route to main channel"
        },
        {
            action: () => modalModule?.CloseAllModals(),
            errorMessage: "Failed to close all modals"
        }
    ];

    let allActionsCompleted = true;

    for (const {action, errorMessage} of recoverySteps) {
        try {
            const result = action();
            await result;
        }
        catch (error) {
            Logger.error("Recovery", `${errorMessage}:, ${error}`);
            allActionsCompleted = false;
        }
    }

    return allActionsCompleted;
}

const parseGithubUrl = (url) => {
    try {
        const urlObj = new URL(url?.replace(/^(http:\/\/|git:\/\/|git\+https:\/\/|git@)/, "https://"));
        if (!urlObj.hostname.includes("github")) return null;
        const [owner, repo] = urlObj.pathname.split("/").filter(Boolean);
        return owner && repo ? `https://github.com/${owner}/${repo.replace(/\.git$/, "")}` : null;
    }
    catch {
        return null;
    }
};

const ErrorDetails = ({componentStack, pluginInfo, stack, instance}) => {
    const [isExpanded, setIsExpanded] = React.useState(false);
    const [height, setHeight] = React.useState(0);
    const contentRef = React.useRef(null);

    React.useEffect(() => {
        const updateHeight = () => {
            if (isExpanded) {
                const maxHeight = Math.min(0.6 * window.innerHeight, 534);
                setHeight(maxHeight);
            }
            else {
                setHeight(0);
            }
        };

        updateHeight();
        window.addEventListener("resize", updateHeight);
        return () => window.removeEventListener("resize", updateHeight);
    }, [isExpanded]);

    const openGithubIssue = () => {
        if (pluginInfo?.githubUrl) {
            const baseRepoUrl = parseGithubUrl(pluginInfo.githubUrl);
            if (!baseRepoUrl) return;

            const issueTitle = encodeURIComponent(`[Bug Report] Plugin Crash - ${pluginInfo?.name} v${pluginInfo?.version}`);
            const issueBody = encodeURIComponent(
                `### Error Details\n\`\`\`js\n${stack}\n\`\`\`\n - Generated by BD Recovery Builtin.` + "\n\n### Steps to Reproduce\n1.\n2.\n3.\n\n" + "### Additional Context\n"
            );
            window.open(`${baseRepoUrl}/issues/new?title=${issueTitle}&body=${issueBody}`, "_blank");
        }
    };

    const openDiscordSupport = async () => {
        if (pluginInfo?.invite) {
            const recoverySuccessful = await attemptRecovery();
            if (recoverySuccessful) {
                instance.setState({info: null, error: null});
                if (pluginInfo.invite) Modals.showGuildJoinModal(pluginInfo.invite);
            }
            else {
                Toasts.show(t("Toasts.recoveryFailed"));
            }
        }
    };

    // TODO: move UI to ui, keep separate from logic
    return (
        <div className="bd-error-container">
            <div className="bd-error-toggle-wrapper">
                <Button
                    className={`bd-error-toggle ${isExpanded ? "expanded" : ""}`}
                    onClick={() => setIsExpanded(!isExpanded)}
                >
                    {isExpanded ? "Hide Error Details ▼" : "Show Error Details ▶"}
                </Button>
                <div className="bd-error-actions">
                    {pluginInfo?.githubUrl && (
                        <Button
                            className="bd-error-github"
                            onClick={openGithubIssue}
                            color={Colors.YELLOW}
                        >
                            {t("Collections.settings.developer.recovery.report")}
                        </Button>
                    )}
                    {pluginInfo?.invite && (
                        <Button
                            className="bd-error-discord"
                            onClick={openDiscordSupport}
                        >
                            {t("Addons.invite")}
                        </Button>
                    )}
                    <Button
                        className="bd-error-safe-mode"
                        onClick={async () => {
                            pluginmanager.addonList.forEach((x) => pluginmanager.disableAddon(x.name));
                            await IPC.relaunch();
                        }}
                        color={Colors.RED}
                    >
                        {t("Collections.settings.developer.recovery.safeMode")}
                    </Button>
                </div>
            </div>
            <div
                className="bd-error-content-wrapper"
                style={{height: `${height}px`, overflow: "hidden"}}
            >
                <div ref={contentRef} className="bd-error-content">
                    {componentStack}
                </div>
            </div>
        </div>
    );
};

export default new class Recovery extends Builtin {
    get name() {return "Recovery";}
    get category() {return "developer";}
    get id() {return "recovery";}

    async enabled() {
        this.patchErrorBoundry();
        this.parseModule = getByKeys(["defaultRules", "parse"]);
    }

    async disabled() {
        this.unpatchAll();
    }

    getPluginInfo(pluginName) {
        try {
            const plugin = pluginmanager.getPlugin(pluginName);
            return {
                name: plugin.name || pluginName,
                githubUrl: plugin.source || plugin.github,
                invite: plugin.invite || null,
                version: plugin.version || `0.0.0`
            };
        }
        catch (error) {
            Logger.error("Recovery", `Failed to get plugin info: ${error}`);
            return null;
        }
    }

    patchErrorBoundry() {
        const mod = getByPrototypes(["_handleSubmitReport"]);

        this.after(mod?.prototype, "render", (instance, args, retValue) => {
            if (!Settings.get(this.collection, this.category, this.id)) return;
            const buttons = retValue?.props?.action?.props;

            if (!buttons) return;

            const errorStack = instance.state;
            const parsedError = errorStack ? this.parseModule.parse(`\`\`\`${errorStack.error?.stack}\n\n${errorStack.info?.componentStack}\`\`\``) : null;

            const foundIssue = TEST_PLUGIN_REGEX.exec(errorStack.error?.stack);
            let pluginInfo = null;

            if (foundIssue) {
                const pluginName = `${foundIssue[2]}.plugin.js`;
                pluginInfo = this.getPluginInfo(pluginName);
                pluginmanager.disableAddon(foundIssue[2]);
                NotificationUIInstance.show({
                    id: "plugin-crash",
                    title: t("Addons.disabled", {name: pluginName}),
                    content: t("Modals.addonCrashed"),
                    duration: Infinity,
                    type: "info",
                    icon: () => <Logo size={16} accent />,
                    actions: [
                        ...(config.isCanary ? [{
                            label: "Re-enable",
                            onClick: () => pluginmanager.enableAddon(foundIssue[2]),
                            dontClose: true,
                        }] : [])
                    ]
                });
            }

            buttons.className = clsx(buttons.className, "bd-recovery-buttons");
            buttons.children.push(
                <Button
                    className="bd-button-recovery"
                    onClick={async () => {
                        const recoverySuccessful = await attemptRecovery();
                        if (recoverySuccessful) {
                            instance.setState({info: null, error: null});
                        }
                        else {
                            Toasts.show(t("Toasts.recoveryFailed"));
                        }
                    }}
                >
                    {t("Collections.settings.developer.recovery.button")}
                </Button>
            );

            if (parsedError) {
                retValue.props.action = [
                    retValue?.props?.action,
                    <ErrorDetails componentStack={parsedError} stack={errorStack?.error?.stack} pluginInfo={pluginInfo} instance={instance} />
                ];
            }
        });
    }
};